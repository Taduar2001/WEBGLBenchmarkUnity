<script>
  const frame = document.getElementById('game-frame');
  // вычисляем ОРИГИН айфрейма из src — не хардкодим
  const FRAME_ORIGIN = new URL(frame.src, location.href).origin;

  const randomBtn   = document.getElementById('randomBtn');
  const openBtn     = document.getElementById('openBtn');
  const closeBtn    = document.getElementById('closeBtn');
  const userIdInput = document.getElementById('userIdInput');
  const hint        = document.getElementById('hint');

  let currentOpen = null;

  function post(type, payload) {
    frame.contentWindow?.postMessage({ type, payload }, FRAME_ORIGIN);
  }

  // небольшой помощник для показа инфы о кусочке
  function pieceToText(payload) {
    const p = payload?.piece || {};
    const id = p.user_id || '—';
    const title = p.title || p.name || '';
    const fill = (p.filling_id ?? '') + '';
    return `user_id=${id}${title ? `, title="${title}"` : ''}${fill ? `, filling_id=${fill}` : ''}`;
  }

  window.addEventListener('message', (e) => {
    // дебаг: смотри, что реально приходит
    console.log('[parent <- child]', e.origin, e.data);

    // принимаем только сообщения именно от айфрейма
    if (e.origin !== FRAME_ORIGIN) return;

    const { type, payload } = e.data || {};

    switch (type) {
      case 'IFRAME_READY':
        hint.textContent = 'Iframe жив. Ждём данные…';
        post('QUERY_INFO');
        break;

      case 'INFO': {
        const n = payload?.piecesCount ?? 0;
        if (n > 0) {
          hint.textContent = `Данные готовы: ${n} кусочков.`;
          randomBtn.disabled = false;
          openBtn.disabled = false;
        } else {
          hint.textContent = 'Данных пока нет, ждём…';
          setTimeout(() => post('QUERY_INFO'), 800);
        }
        break;
      }

      case 'BUSY_STATE': {
        const busy = !!payload?.busy;
        // Важно: не трогаем closeBtn здесь, иначе он гаснет при LockedOut
        randomBtn.disabled = busy;
        openBtn.disabled   = busy;
        break;
      }

      case 'OPENING': {
        currentOpen = payload || null;
        hint.textContent = `Открываем: ${pieceToText(payload)}`;
        break;
      }

      case 'OPENED': {
        currentOpen = payload || null;
        hint.textContent = `Открыт: ${pieceToText(payload)}`;
        closeBtn.disabled = false; // включаем закрытие только здесь
        break;
      }

      case 'CLOSED': {
        currentOpen = null;
        hint.textContent = 'Кусочек закрыт.';
        closeBtn.disabled = true;
        break;
      }

      case 'OPEN_FAILED': {
        currentOpen = null;
        hint.textContent = 'Ошибка открытия.';
        closeBtn.disabled = true;
        break;
      }

      case 'OPEN_RESULT': {
        // опционально: спросим актуальную занятость
        setTimeout(() => post('QUERY_BUSY'), 200);
        break;
      }

      case 'CLOSE_RESULT': {
        if (!payload?.ok) console.warn('Не удалось закрыть (ничего не открыто?)');
        break;
      }
    }
  });

  // кнопки
  randomBtn.addEventListener('click', () => post('OPEN_RANDOM'));
  openBtn.addEventListener('click', () => {
    const id = userIdInput.value.trim();
    if (!id) { alert('Введите user_id'); return; }
    post('OPEN_BY_USER', { userId: id });
  });
  // закрывает ЛЮБОЙ открытый кусок (и вручную открытый, и программно)
  closeBtn.addEventListener('click', () => post('CLOSE_ANY'));
</script>
